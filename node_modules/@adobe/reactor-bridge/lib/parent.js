'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setDebug = exports.setPromise = exports.loadIframe = exports.ERROR_CODES = undefined;

var _penpal = require('penpal');

var _penpal2 = _interopRequireDefault(_penpal);

var _logger = require('./utils/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***************************************************************************************
 * (c) 2017 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 ****************************************************************************************/

var CONNECTION_TIMEOUT_DURATION = 10000;
var RENDER_TIMEOUT_DURATION = 2000;

var logger = new _logger2.default('ExtensionBridge:Parent');
var noop = function noop() {};

var Promise = window.Promise;

var ERROR_CODES = exports.ERROR_CODES = {
  CONNECTION_TIMEOUT: 'connectionTimeout',
  RENDER_TIMEOUT: 'renderTimeout',
  DESTROYED: 'destroyed'
};

/**
 * An object providing bridge-related API.
 * @typedef {Object} Bridge
 * @property {Promise} The promise will be resolved once (1) communication with the iframe has
 * been established, (2) the iframe has been resized to its content, and (3) the iframe has
 * acknowledged receiving the initial init() call. The promise will be resolved
 * with an {IframeAPI} object that will act as the API to use to communicate with the iframe.
 * @property {HTMLIframeElement} iframe The created iframe. You may use this to add classes to the
 * iframe, etc.
 * @property {Function} destroy Removes the iframe from its container and cleans up any supporting
 * utilities.
 */

/**
 * An API the consumer will use to call methods on the iframe.
 * @typedef {Object} IframeAPI
 * @property {Function} validate Validates the extension view.
 * @property {Function} getSettings Retrieves settings from the extension view.
 */

/**
 * Loads an extension iframe and connects all the necessary APIs.
 * @param {Object} options
 * @param {string} options.url The URL of the extension view to load.
 * @param {Object} [options.extensionInitOptions={}] The options to be passed to the initial init()
 * call on the extension view.
 * @param {HTMLElement} [options.container=document.body] The container DOM element to which the
 * extension iframe should be added.
 * @param {number} [options.connectionTimeoutDuration=10000] The amount of time, in milliseconds,
 * that must pass while attempting to establish communication with the iframe before rejecting
 * the returned promise with a CONNECTION_TIMEOUT error code.
 * @param {number} [options.renderTimeoutDuration=2000] The amount of time, in milliseconds,
 * that must pass while attempting to render the iframe before rejecting the returned promise
 * with a RENDER_TIMEOUT error code. This duration begins after communication with the iframe
 * has been established.
 * @param {Function} [options.openCodeEditor] The function to call when the extension view requests
 * that the code editor should open. The function may be passed existing code and should return
 * a promise to be resolved with updated code.
 * @param {Function} [options.openRegexTester] The function to call when the extension view requests
 * that the regex tester should open. The function may be passed an existing regular expression
 * string and should return a promise to be resolved with an updated regular expression string.
 * @param {Function} [options.openDataElementSelector] The function to call when the extension view
 * requests that the data element selector should open. The function should return a promise that
 * is resolved with the selected data element name.
 * @param {Function} [options.openCssSelector] The function to call when the extension view requests
 * that the CSS selector should open. The function should return a promise that is resolved
 * with the generated CSS selector.
 * @returns {Bridge}
 */
var loadIframe = exports.loadIframe = function loadIframe(options) {
  var url = options.url,
      _options$extensionIni = options.extensionInitOptions,
      extensionInitOptions = _options$extensionIni === undefined ? {} : _options$extensionIni,
      _options$container = options.container,
      container = _options$container === undefined ? document.body : _options$container,
      _options$connectionTi = options.connectionTimeoutDuration,
      connectionTimeoutDuration = _options$connectionTi === undefined ? CONNECTION_TIMEOUT_DURATION : _options$connectionTi,
      _options$renderTimeou = options.renderTimeoutDuration,
      renderTimeoutDuration = _options$renderTimeou === undefined ? RENDER_TIMEOUT_DURATION : _options$renderTimeou,
      _options$openCodeEdit = options.openCodeEditor,
      openCodeEditor = _options$openCodeEdit === undefined ? noop : _options$openCodeEdit,
      _options$openRegexTes = options.openRegexTester,
      openRegexTester = _options$openRegexTes === undefined ? noop : _options$openRegexTes,
      _options$openDataElem = options.openDataElementSelector,
      openDataElementSelector = _options$openDataElem === undefined ? noop : _options$openDataElem,
      _options$openCssSelec = options.openCssSelector,
      openCssSelector = _options$openCssSelec === undefined ? noop : _options$openCssSelec;


  var destroy = void 0;
  var iframe = void 0;

  var createOpenSharedViewProxy = function createOpenSharedViewProxy(openSharedViewFn) {
    return function () {
      var promise = Promise.resolve(openSharedViewFn.apply(undefined, arguments));
      return promise;
    };
  };

  var loadPromise = new Promise(function (resolve, reject) {
    var connectionTimeoutId = setTimeout(function () {
      reject(ERROR_CODES.CONNECTION_TIMEOUT);
      destroy();
    }, connectionTimeoutDuration);

    var childConfig = {
      url: url,
      appendTo: container,
      methods: {
        openCodeEditor: createOpenSharedViewProxy(openCodeEditor),
        openRegexTester: createOpenSharedViewProxy(openRegexTester),
        openDataElementSelector: createOpenSharedViewProxy(openDataElementSelector),
        openCssSelector: createOpenSharedViewProxy(openCssSelector)
      }
    };
    var penpalConnection = _penpal2.default.connectToChild(childConfig);

    penpalConnection.promise.then(function (child) {
      clearTimeout(connectionTimeoutId);

      var renderTimeoutId = setTimeout(function () {
        reject(ERROR_CODES.RENDER_TIMEOUT);
        destroy();
      }, renderTimeoutDuration);

      child.init(extensionInitOptions).then(function () {
        logger.log('Init complete.');
        clearTimeout(renderTimeoutId);
        resolve({
          init: child.init,
          validate: child.validate,
          getSettings: child.getSettings
        });
      }).catch(function (error) {
        clearTimeout(renderTimeoutId);
        reject('Initialization failed: ' + error);
      });
    }, function (error) {
      reject('Connection failed: ' + error);
    });

    destroy = function destroy() {
      reject(ERROR_CODES.DESTROYED);
      penpalConnection.destroy();
    };

    iframe = penpalConnection.iframe;
  });

  iframe.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups');

  return {
    promise: loadPromise,
    iframe: iframe,
    destroy: destroy
  };
};

var setPromise = exports.setPromise = function setPromise(value) {
  Promise = value;
  _penpal2.default.Promise = value;
};
var setDebug = exports.setDebug = function setDebug(value) {
  _penpal2.default.debug = value;
  _logger2.default.enabled = value;
};